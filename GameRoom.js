import{Deck}from'./Deck.js';import{GameRules}from'./GameRules.js';import{Validator}from'./Validator.js';import{CPUAI}from'./CPUAI.js';import{RankSystem}from'./RankSystem.js';export class GameRoom{constructor(code,host,opts){this.roomCode=code;this.hostId=host;this.options={...GameRules.getDefaultOptions(),...opts};this.players=[];this.gameState={phase:'waiting',currentPlayerIndex:0,lastPlay:{type:'none',cards:[],rank:0,length:0},lastPlayerId:null,pile:[],passCount:0,finishOrder:[],round:0,roles:{},swapPending:{},swapsCompleted:{},gameLog:[]};}log(msg){const ts=new Date().toLocaleTimeString();const entry={timestamp:ts,msg,type:'info'};this.gameState.gameLog.push(entry);if(this.gameState.gameLog.length>100)this.gameState.gameLog.shift();}addPlayer(id,name,isCPU=false){if(this.players.length>=this.options.num_players)return{success:false,error:'Full'};this.players.push({id,name,isCPU,hand:[],finished:false,finishPosition:null});this.log(`${name} joined${isCPU?' (CPU)':''}`);return{success:true};}dealCards(){const n=this.options.num_players>4?2:1;const deck=new Deck(n);deck.shuffle();const hands=deck.deal(this.players.length);this.players.forEach((p,i)=>{p.hand=hands[i];p.finished=false;p.finishPosition=null;p.hand=RankSystem.sortCards(p.hand,this.options);});}startGame(){if(this.players.length<2)return{success:false};this.dealCards();this.gameState.currentPlayerIndex=GameRules.getStartingPlayer(this.players);this.gameState.phase='playing';this.gameState.round++;this.gameState.lastPlay={type:'none',cards:[],rank:0,length:0};this.gameState.lastPlayerId=null;this.gameState.pile=[];this.gameState.passCount=0;this.gameState.finishOrder=[];this.log(`Round ${this.gameState.round} started`);return{success:true};}playCards(id,indices){const p=this.players.find(x=>x.id===id);if(!p||this.gameState.phase!=='playing'||p.finished)return{success:false};const curr=this.players[this.gameState.currentPlayerIndex];if(curr.id!==id)return{success:false};const sel=indices.map(i=>p.hand[i]).filter(c=>c);const type=Validator.getPlayType(sel,this.options);if(type.type==='invalid')return{success:false};const beat=Validator.canBeatPlay(type,this.gameState.lastPlay,this.options);if(!beat.canBeat)return{success:false};const str=sel.map(c=>c.rank+c.suit).join(',');this.log(`${p.name} played: ${str}`);p.hand=p.hand.filter((c,i)=>!indices.includes(i));p.hand=RankSystem.sortCards(p.hand,this.options);this.gameState.lastPlayerId=id;this.gameState.lastPlay=type;this.gameState.pile.push(...sel);this.gameState.passCount=0;if(p.hand.length===0){p.finished=true;p.finishPosition=this.gameState.finishOrder.length+1;this.gameState.finishOrder.push(id);this.log(`${p.name} finished #${p.finishPosition}`);if(this.checkRoundEnd()){this.endRound();return{success:true,playType:type,roundEnded:true};}}this.advanceToNextPlayer();return{success:true,playType:type};}passTurn(id){const curr=this.players[this.gameState.currentPlayerIndex];if(curr.id!==id||curr.finished)return{success:false};if(this.gameState.lastPlay.type==='none')return{success:false};this.gameState.passCount++;const active=this.players.filter(p=>!p.finished).length;this.log(`${curr.name} passed`);if(this.gameState.passCount>=active-1){this.log(`Pile cleared`);this.gameState.pile=[];this.gameState.lastPlay={type:'none',cards:[],rank:0,length:0};this.gameState.passCount=0;if(this.gameState.lastPlayerId){const last=this.players.find(p=>p.id===this.gameState.lastPlayerId);if(last&&!last.finished){this.gameState.currentPlayerIndex=this.players.indexOf(last);return{success:true};}}}this.advanceToNextPlayer();return{success:true};}advanceToNextPlayer(){let attempts=0;let next=(this.gameState.currentPlayerIndex+1)%this.players.length;while(this.players[next].finished&&attempts<this.players.length){next=(next+1)%this.players.length;attempts++;}if(attempts>=this.players.length)return;this.gameState.currentPlayerIndex=next;}checkRoundEnd(){return this.players.filter(p=>!p.finished).length<=1;}endRound(){this.log(`Round ${this.gameState.round} ended`);const last=this.players.find(p=>!p.finished);if(last){last.finished=true;last.finishPosition=this.gameState.finishOrder.length+1;this.gameState.finishOrder.push(last.id);this.log(`${last.name} finished #${last.finishPosition}`);}this.gameState.roles=GameRules.assignRoles(this.gameState.finishOrder,this.players.length);this.players.forEach(p=>{const role=this.gameState.roles[p.id];if(role)this.log(`${p.name}: ${role}`);});this.dealCards();this.log(`New hands dealt`);this.gameState.phase='swapping';this.gameState.swapPending={};this.gameState.swapsCompleted={};this.initializeSwaps();}initializeSwaps(){const n=this.players.length;const fo=this.gameState.finishOrder;if(n<2||fo.length<2){this.startGameAfterSwap();return;}if(n===2){this.gameState.swapPending[fo[0]]={to:fo[1],count:1,cards:[]};this.gameState.swapPending[fo[1]]={to:fo[0],count:1,cards:[]};this.log(`Swap: 1 card each`);}else if(n===3){this.gameState.swapPending[fo[0]]={to:fo[2],count:2,cards:[]};this.gameState.swapPending[fo[2]]={to:fo[0],count:2,cards:[]};this.log(`Swap: President↔Asshole (2)`);}else{if(fo[0]&&fo[n-1]){this.gameState.swapPending[fo[0]]={to:fo[n-1],count:2,cards:[]};this.gameState.swapPending[fo[n-1]]={to:fo[0],count:2,cards:[]};this.log(`Swap: President↔Asshole (2)`);}if(fo[1]&&fo[n-2]){this.gameState.swapPending[fo[1]]={to:fo[n-2],count:1,cards:[]};this.gameState.swapPending[fo[n-2]]={to:fo[1],count:1,cards:[]};this.log(`Swap: VP↔VAP (1)`);}}}submitSwap(id,indices){if(this.gameState.phase!=='swapping')return{success:false};const s=this.gameState.swapPending[id];if(!s||indices.length!==s.count)return{success:false};const p=this.players.find(x=>x.id===id);if(!p)return{success:false};const sel=indices.map(i=>p.hand[i]).filter(c=>c);if(sel.length!==s.count)return{success:false};s.cards=sel;this.gameState.swapsCompleted[id]=true;this.log(`${p.name} submitted swap`);return{success:true,allCompleted:this.checkAndProcessSwaps()};}checkAndProcessSwaps(){const pids=Object.keys(this.gameState.swapPending);if(pids.length===0){this.startGameAfterSwap();return true;}const allDone=pids.every(id=>this.gameState.swapsCompleted[id]);if(!allDone)return false;this.log(`Processing swaps...`);for(const fid of pids){const s=this.gameState.swapPending[fid];const f=this.players.find(p=>p.id===fid);const t=this.players.find(p=>p.id===s.to);if(!f||!t)continue;for(const c of s.cards){const idx=f.hand.findIndex(x=>x.rank===c.rank&&x.suit===c.suit);if(idx!==-1){f.hand.splice(idx,1);t.hand.push(c);}}}this.players.forEach(p=>{p.hand=RankSystem.sortCards(p.hand,this.options);});this.log(`Swaps complete`);this.startGameAfterSwap();return true;}startGameAfterSwap(){let ah=null;for(const p of this.players){const r=this.gameState.roles[p.id];if(r==='Asshole'||r==='Vice Asshole'){ah=p;break;}}this.gameState.currentPlayerIndex=ah?this.players.indexOf(ah):0;this.gameState.phase='playing';this.gameState.round++;this.gameState.lastPlay={type:'none',cards:[],rank:0,length:0};this.gameState.lastPlayerId=null;this.gameState.pile=[];this.gameState.passCount=0;this.gameState.finishOrder=[];this.gameState.swapPending={};this.gameState.swapsCompleted={};this.log(`Round ${this.gameState.round} started (${this.players[this.gameState.currentPlayerIndex].name} begins)`);}autoSwapForCPU(id){const s=this.gameState.swapPending[id];if(!s)return;const p=this.players.find(x=>x.id===id);if(!p||p.hand.length<s.count)return;const r=this.gameState.roles[id];const so=RankSystem.sortCards(p.hand,this.options);const idx=(r==='Asshole'||r==='Vice Asshole')?so.slice(-s.count).map(c=>p.hand.findIndex(x=>x.rank===c.rank&&x.suit===c.suit)):so.slice(0,s.count).map(c=>p.hand.findIndex(x=>x.rank===c.rank&&x.suit===c.suit));this.submitSwap(id,idx);}isCurrentPlayerCPU(){return this.players[this.gameState.currentPlayerIndex]?.isCPU||false;}executeCPUTurn(){const curr=this.players[this.gameState.currentPlayerIndex];if(!curr?.isCPU||curr.finished)return{success:false};const d=CPUAI.decideTurn(curr.hand,this.gameState.lastPlay,this.options);return d.action==='play'?this.playCards(curr.id,d.cardIndices):this.passTurn(curr.id);}getPublicState(rid){const curr=this.players[this.gameState.currentPlayerIndex];return{roomCode:this.roomCode,phase:this.gameState.phase,round:this.gameState.round,currentPlayerIndex:this.gameState.currentPlayerIndex,currentPlayerId:curr?.id,currentPlayerName:curr?.name,isYourTurn:curr?.id===rid,lastPlay:this.gameState.lastPlay,lastPlayerId:this.gameState.lastPlayerId,roles:this.gameState.roles,swapRequired:this.gameState.swapPending[rid]||null,swapsCompleted:this.gameState.swapsCompleted,gameLog:this.gameState.gameLog,players:this.players.map(p=>({id:p.id,name:p.name,isCPU:p.isCPU,handSize:p.hand.length,finished:p.finished,finishPosition:p.finishPosition,role:this.gameState.roles[p.id]||null,hand:p.id===rid?p.hand.map(c=>c.toJSON()):null})),finishOrder:this.gameState.finishOrder,options:this.options};}}