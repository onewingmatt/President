import express from'express';import{createServer}from'http';import{Server}from'socket.io';import cors from'cors';import path from'path';import{fileURLToPath}from'url';import{GameRoom}from'./GameRoom.js';const __filename=fileURLToPath(import.meta.url);const __dirname=path.dirname(__filename);const app=express();const server=createServer(app);const io=new Server(server,{cors:{origin:'*'},transports:['websocket','polling'],pingTimeout:60000,pingInterval:25000});app.use(cors());app.use(express.static(__dirname));app.get('/',(req,res)=>{res.sendFile(path.join(__dirname,'index.html'));});app.get('/health',(req,res)=>{res.json({status:'ok',rooms:gameRooms.size,instance:process.env.FLY_ALLOC_ID||'local'});});const gameRooms=new Map();function generateRoomCode(){return Array(6).fill(0).map(()=>'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'[Math.floor(Math.random()*36)]).join('');}function triggerCPUTurn(io,room,depth=0){if(depth>20||room.gameState.phase!=='playing')return;const current=room.players[room.gameState.currentPlayerIndex];if(!current||!current.isCPU)return;setTimeout(()=>{if(room.gameState.phase!=='playing')return;const result=room.executeCPUTurn();if(!result?.success)return;room.players.forEach(p=>io.to(p.id).emit('game-state-update',room.getPublicState(p.id)));if(result.roundEnded)return;if(room.gameState.phase==='playing'){const next=room.players[room.gameState.currentPlayerIndex];if(next.isCPU)triggerCPUTurn(io,room,depth+1);}},700);}function forceCPUSwaps(room){if(room.gameState.phase!=='swapping')return 0;const cpuPlayers=room.players.filter(p=>p.isCPU&&room.gameState.swapPending[p.id]&&!room.gameState.swapsCompleted[p.id]);console.log(`[${room.roomCode}] FORCING ${cpuPlayers.length} CPU swaps`);cpuPlayers.forEach(cpu=>{room.autoSwapForCPU(cpu.id);console.log(`[${room.roomCode}] FORCED CPU ${cpu.name} to swap`);});return cpuPlayers.length;}function startWatchdog(io,roomCode){setInterval(()=>{const room=gameRooms.get(roomCode);if(!room)return;if(room.gameState.phase==='playing'&&room.isCurrentPlayerCPU()){console.log(`[${roomCode}] WATCHDOG: CPU turn detected, triggering`);triggerCPUTurn(io,room);}if(room.gameState.phase==='swapping'){const pending=Object.keys(room.gameState.swapPending).filter(id=>!room.gameState.swapsCompleted[id]);const cpuPending=pending.filter(id=>room.players.find(p=>p.id===id&&p.isCPU));if(cpuPending.length>0){console.log(`[${roomCode}] WATCHDOG: ${cpuPending.length} CPU swaps pending, forcing`);forceCPUSwaps(room);room.players.forEach(p=>io.to(p.id).emit('game-state-update',room.getPublicState(p.id)));}}},3000);}io.on('connection',(socket)=>{const instanceId=process.env.FLY_ALLOC_ID||'local';console.log(`[CONNECT] New connection: ${socket.id} on instance ${instanceId}`);socket.on('create-game',(data)=>{const code=generateRoomCode();console.log(`[CREATE] Generating room code: ${code} on instance ${instanceId}`);const numPlayers=Math.min(8,Math.max(2,data.options?.num_players||4));const numCPU=Math.min(numPlayers-1,Math.max(0,data.options?.numCPU||0));const room=new GameRoom(code,socket.id,{num_players:numPlayers,num_decks:numPlayers>4?2:1});room.addPlayer(socket.id,data.playerName,false);for(let i=0;i<numCPU;i++){room.addPlayer('CPU-'+i+'-'+Date.now()+'-'+Math.random(),'CPU '+(i+1),true);}gameRooms.set(code,room);console.log(`[CREATE] Room ${code} created and stored in Map`);console.log(`[CREATE] Total rooms: ${gameRooms.size}, Codes: ${Array.from(gameRooms.keys()).join(', ')}`);socket.join(code);console.log(`[CREATE] Socket ${socket.id} joined room ${code}`);socket.emit('game-created',{roomCode:code});console.log(`[CREATE] Emitted game-created with roomCode: ${code}`);io.to(code).emit('game-state-update',room.getPublicState(socket.id));console.log(`[CREATE] Room ${code} ready for joins by ${data.playerName}`);});socket.on('join-game',(data)=>{console.log(`[JOIN] Received join request - Raw code: "${data.roomCode}" on instance ${instanceId}`);const roomCode=data.roomCode.toUpperCase().trim();console.log(`[JOIN] Processed code: "${roomCode}"`);console.log(`[JOIN] Available rooms: ${Array.from(gameRooms.keys()).join(', ')}`);console.log(`[JOIN] Total rooms in Map: ${gameRooms.size}`);const room=gameRooms.get(roomCode);if(!room){console.log(`[JOIN] ❌ Room ${roomCode} NOT FOUND on instance ${instanceId}`);console.log(`[JOIN] Keys in Map: ${JSON.stringify(Array.from(gameRooms.keys()))}`);socket.emit('error',{message:'Room not found'});return;}console.log(`[JOIN] ✅ Room ${roomCode} found on instance ${instanceId}!`);console.log(`[JOIN] Room phase: ${room.gameState.phase}`);console.log(`[JOIN] Current players: ${room.players.length}/${room.options.num_players}`);const result=room.addPlayer(socket.id,data.playerName,false);if(!result.success){console.log(`[JOIN] ❌ Failed to add player: ${result.error}`);socket.emit('error',{message:result.error});return;}socket.join(roomCode);console.log(`[JOIN] ✅ ${data.playerName} joined ${roomCode} successfully`);socket.emit('game-created',{roomCode:roomCode});io.to(roomCode).emit('game-state-update',room.getPublicState(socket.id));console.log(`[JOIN] Sent game state to all players in ${roomCode}`);});socket.on('rejoin-game',(data)=>{const roomCode=data.roomCode.toUpperCase().trim();const room=gameRooms.get(roomCode);if(!room){socket.emit('error',{message:'Room not found'});return;}console.log(`[${roomCode}] Player ${data.playerName} rejoining`);const existingPlayer=room.players.find(p=>p.name===data.playerName&&!p.isCPU);if(existingPlayer){existingPlayer.id=socket.id;socket.join(roomCode);socket.emit('game-state-update',room.getPublicState(socket.id));console.log(`[${roomCode}] Player ${data.playerName} reconnected`);}else{socket.emit('error',{message:'Player not found'});}});socket.on('start-game',(data)=>{const roomCode=data.roomCode.toUpperCase().trim();const room=gameRooms.get(roomCode);if(!room||room.hostId!==socket.id)return;console.log(`[${roomCode}] Starting game with ${room.players.length} players`);room.startGame();io.to(roomCode).emit('game-started');room.players.forEach(p=>io.to(p.id).emit('game-state-update',room.getPublicState(p.id)));startWatchdog(io,roomCode);console.log(`[${roomCode}] Game started, watchdog active`);setTimeout(()=>{if(room.gameState.phase==='playing'&&room.isCurrentPlayerCPU())triggerCPUTurn(io,room);},1000);});socket.on('play-cards',(data)=>{const roomCode=data.roomCode.toUpperCase().trim();const room=gameRooms.get(roomCode);if(!room)return;const result=room.playCards(socket.id,data.cardIndices);if(result.success){room.players.forEach(p=>io.to(p.id).emit('game-state-update',room.getPublicState(p.id)));if(result.roundEnded){setTimeout(()=>{room.players.forEach(p=>io.to(p.id).emit('game-state-update',room.getPublicState(p.id)));setTimeout(()=>{const forced=forceCPUSwaps(room);room.players.forEach(p=>io.to(p.id).emit('game-state-update',room.getPublicState(p.id)));},1000);},500);}else if(room.gameState.phase==='playing'){const next=room.players[room.gameState.currentPlayerIndex];if(next.isCPU)setTimeout(()=>triggerCPUTurn(io,room),400);}}});socket.on('pass-turn',(data)=>{const roomCode=data.roomCode.toUpperCase().trim();const room=gameRooms.get(roomCode);if(!room)return;const result=room.passTurn(socket.id);if(result.success){room.players.forEach(p=>io.to(p.id).emit('game-state-update',room.getPublicState(p.id)));if(room.gameState.phase==='playing'){const next=room.players[room.gameState.currentPlayerIndex];if(next.isCPU)setTimeout(()=>triggerCPUTurn(io,room),400);}}});socket.on('submit-swap',(data)=>{const roomCode=data.roomCode.toUpperCase().trim();const room=gameRooms.get(roomCode);if(!room)return;const forced=forceCPUSwaps(room);const result=room.submitSwap(socket.id,data.cardIndices);if(result.success){room.players.forEach(p=>io.to(p.id).emit('game-state-update',room.getPublicState(p.id)));if(result.allCompleted&&room.gameState.phase==='playing'){setTimeout(()=>{if(room.isCurrentPlayerCPU())triggerCPUTurn(io,room);},500);}}});socket.on('ready-neutral',(data)=>{const roomCode=data.roomCode.toUpperCase().trim();const room=gameRooms.get(roomCode);if(!room)return;const forced=forceCPUSwaps(room);room.players.forEach(p=>io.to(p.id).emit('game-state-update',room.getPublicState(p.id)));if(room.gameState.phase==='playing'){setTimeout(()=>{if(room.isCurrentPlayerCPU())triggerCPUTurn(io,room);},500);}});socket.on('disconnect',()=>{console.log(`[DISCONNECT] Socket ${socket.id} disconnected`);});});const PORT=process.env.PORT||8080;server.listen(PORT,'0.0.0.0',()=>{const instanceId=process.env.FLY_ALLOC_ID||'local';console.log('✅ v1.6.53 - Single instance fix');console.log(`   Server running on port ${PORT}`);console.log(`   Instance ID: ${instanceId}`);});